# üìò Aula 08 ‚Äî √Årvores Bin√°rias e Busca Bin√°ria (Binary Trees & BSTs)

## üéØ Objetivos da Aula
- Entender o conceito de **√°rvores bin√°rias** e **√°rvores de busca bin√°ria (BST)**.
- Criar e manipular n√≥s de √°rvores em C#.
- Implementar opera√ß√µes b√°sicas: inser√ß√£o, busca, percursos e remo√ß√£o.
- Explorar percursos cl√°ssicos: **pr√©-ordem**, **em-ordem** e **p√≥s-ordem**.
- Resolver problemas cl√°ssicos de entrevistas usando √°rvores bin√°rias.

---

## üå≥ 1. O Que √© uma √Årvore Bin√°ria?

Uma **√°rvore bin√°ria** √© uma estrutura hier√°rquica composta por **n√≥s**:
- Cada n√≥ tem **at√© dois filhos**: esquerdo e direito.
- O n√≥ mais alto √© chamado de **raiz**.
- N√≥s sem filhos s√£o chamados de **folhas**.

üí° **Analogia Feynman:**  
Pense em uma √°rvore geneal√≥gica: cada pessoa (n√≥) tem dois filhos poss√≠veis, conectados hierarquicamente.

---

## üß© 2. Estrutura B√°sica de um N√≥

```csharp
class Node {
    public int Valor;
    public Node Esquerda;
    public Node Direita;

    public Node(int valor) {
        Valor = valor;
        Esquerda = null;
        Direita = null;
    }
}
```

---

## üå≤ 3. √Årvore de Busca Bin√°ria (BST)

A **BST (Binary Search Tree)** √© uma √°rvore bin√°ria com a seguinte propriedade:
- Todos os valores √† **esquerda** de um n√≥ s√£o **menores** que ele.
- Todos os valores √† **direita** s√£o **maiores**.

Isso permite **buscas e inser√ß√µes eficientes**, geralmente em **O(log n)**.

---

### üìç Exemplo ‚Äî Inser√ß√£o em uma BST

```csharp
class BST {
    public Node Raiz;

    public void Inserir(int valor) {
        Raiz = InserirRecursivo(Raiz, valor);
    }

    private Node InserirRecursivo(Node raiz, int valor) {
        if (raiz == null) return new Node(valor);

        if (valor < raiz.Valor)
            raiz.Esquerda = InserirRecursivo(raiz.Esquerda, valor);
        else if (valor > raiz.Valor)
            raiz.Direita = InserirRecursivo(raiz.Direita, valor);

        return raiz;
    }
}
```

**Exemplo de uso:**

```csharp
var bst = new BST();
bst.Inserir(50);
bst.Inserir(30);
bst.Inserir(70);
bst.Inserir(20);
bst.Inserir(40);
bst.Inserir(60);
bst.Inserir(80);
```

---

## üîé 4. Busca em uma BST

```csharp
bool Buscar(Node raiz, int valor) {
    if (raiz == null) return false;
    if (raiz.Valor == valor) return true;
    if (valor < raiz.Valor) return Buscar(raiz.Esquerda, valor);
    else return Buscar(raiz.Direita, valor);
}
```

**Entrada:** valor = 40 ‚Üí **Sa√≠da:** `true`  
**Complexidade:** O(log n)

---

## üîÅ 5. Percursos (Traversals)

### 1Ô∏è‚É£ Pr√©-Ordem (Root ‚Üí Left ‚Üí Right)

```csharp
void PreOrdem(Node raiz) {
    if (raiz == null) return;
    Console.Write(raiz.Valor + " ");
    PreOrdem(raiz.Esquerda);
    PreOrdem(raiz.Direita);
}
```

### 2Ô∏è‚É£ Em-Ordem (Left ‚Üí Root ‚Üí Right)

```csharp
void EmOrdem(Node raiz) {
    if (raiz == null) return;
    EmOrdem(raiz.Esquerda);
    Console.Write(raiz.Valor + " ");
    EmOrdem(raiz.Direita);
}
```

### 3Ô∏è‚É£ P√≥s-Ordem (Left ‚Üí Right ‚Üí Root)

```csharp
void PosOrdem(Node raiz) {
    if (raiz == null) return;
    PosOrdem(raiz.Esquerda);
    PosOrdem(raiz.Direita);
    Console.Write(raiz.Valor + " ");
}
```

---

## üåø 6. Menor e Maior Elemento

```csharp
int Minimo(Node raiz) {
    while (raiz.Esquerda != null)
        raiz = raiz.Esquerda;
    return raiz.Valor;
}

int Maximo(Node raiz) {
    while (raiz.Direita != null)
        raiz = raiz.Direita;
    return raiz.Valor;
}
```

**Entrada:** `[50, 30, 70, 20, 40, 60, 80]`  
**Sa√≠da:** `Min=20, Max=80`

---

## ‚ùå 7. Remover um Elemento

```csharp
Node Remover(Node raiz, int valor) {
    if (raiz == null) return raiz;

    if (valor < raiz.Valor)
        raiz.Esquerda = Remover(raiz.Esquerda, valor);
    else if (valor > raiz.Valor)
        raiz.Direita = Remover(raiz.Direita, valor);
    else {
        // Caso 1: sem filhos
        if (raiz.Esquerda == null) return raiz.Direita;
        else if (raiz.Direita == null) return raiz.Esquerda;

        // Caso 2: dois filhos
        raiz.Valor = Minimo(raiz.Direita);
        raiz.Direita = Remover(raiz.Direita, raiz.Valor);
    }
    return raiz;
}
```

---

## üß© 8. Exerc√≠cios da Aula 08

**Ex 1.** Implemente uma √°rvore bin√°ria simples com inser√ß√£o e percurso em ordem.  
**Ex 2.** Adicione uma fun√ß√£o que conte o n√∫mero total de n√≥s.  
**Ex 3.** Crie um m√©todo que calcule a **altura da √°rvore**.  
**Ex 4.** Implemente uma fun√ß√£o para retornar o **m√≠nimo e m√°ximo** da BST.  
**Ex 5.** Fa√ßa uma fun√ß√£o que retorne `true` se a √°rvore for uma **BST v√°lida**.

---

## üí™ 9. Desafio Extra ‚Äî Caminho da Raiz at√© a Folha com Soma Alvo

Dado um valor alvo, determine se h√° um caminho da **raiz at√© uma folha** cuja soma dos valores dos n√≥s seja igual ao alvo.

```csharp
bool TemCaminhoComSoma(Node raiz, int soma) {
    if (raiz == null) return false;
    if (raiz.Esquerda == null && raiz.Direita == null && raiz.Valor == soma)
        return true;
    return TemCaminhoComSoma(raiz.Esquerda, soma - raiz.Valor) ||
           TemCaminhoComSoma(raiz.Direita, soma - raiz.Valor);
}
```

**Entrada:** soma = 100, √°rvore `[50,30,20,40,70,60,80]`  
**Sa√≠da:** `true` (50 + 30 + 20 = 100)

---

## üß† 10. Feynman ‚Äî Explica√ß√£o com Suas Palavras

Responda:
1. Qual a principal diferen√ßa entre √°rvore bin√°ria e BST?  
2. Por que o percurso em ordem imprime os valores ordenados em uma BST?  
3. O que acontece ao remover um n√≥ com dois filhos?  
4. Como a busca bin√°ria reduz o n√∫mero de compara√ß√µes?  
5. Cite um exemplo real de estrutura de √°rvore.

üìù Escreva suas respostas em at√© **150 palavras**.
