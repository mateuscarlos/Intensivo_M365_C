# ğŸ“˜ Aula 04 â€” Two Pointers e Sliding Window

## ğŸ¯ Objetivos da Aula
- Entender o conceito de **Two Pointers** e **Sliding Window**.
- Resolver problemas clÃ¡ssicos de arrays e strings com eficiÃªncia.
- Reduzir complexidade de O(nÂ²) para O(n).
- Aplicar lÃ³gica de movimentaÃ§Ã£o simultÃ¢nea de ponteiros.
- Desenvolver soluÃ§Ãµes otimizadas no estilo **HackerRank/LeetCode**.

---

## ğŸ§  1. Conceito de Two Pointers

A tÃ©cnica **Two Pointers (dois ponteiros)** usa duas variÃ¡veis (Ã­ndices) que percorrem uma estrutura ao mesmo tempo.

ğŸ’¡ **Analogia Feynman:** imagine duas pessoas caminhando em uma estrada (array):
- Uma anda rÃ¡pido (ponteiro direito);
- Outra anda devagar (ponteiro esquerdo);
- Elas se aproximam, se afastam ou percorrem a estrada para encontrar um padrÃ£o.

---

### ğŸ“ Exemplo 1 â€” Remover Duplicados em Array Ordenado

```csharp
int RemoveDuplicados(int[] nums) {
    if (nums.Length == 0) return 0;
    int i = 0;
    for (int j = 1; j < nums.Length; j++) {
        if (nums[j] != nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}
```

- **Entrada:** `[1,1,2,2,3]`
- **SaÃ­da:** `3` (Array final: `[1,2,3,_,_]`)
- **Complexidade:** O(n)

---

## ğŸ§® 2. Conceito de Sliding Window

A tÃ©cnica **Sliding Window (janela deslizante)** mantÃ©m uma *subestrutura contÃ­nua* dentro de uma sequÃªncia.
A janela se expande ou contrai conforme a condiÃ§Ã£o do problema.

ğŸ’¡ **Analogia:**  
Pense em uma janela de vidro deslizando sobre uma linha de nÃºmeros â€” vocÃª vÃª apenas uma parte da sequÃªncia de cada vez.

---

### ğŸ“ Exemplo 2 â€” Maior Soma de Subarray de Tamanho Fixo K

```csharp
int MaxSomaSubarray(int[] arr, int k) {
    int soma = 0, maxSoma = 0;

    for (int i = 0; i < k; i++)
        soma += arr[i];
    maxSoma = soma;

    for (int i = k; i < arr.Length; i++) {
        soma += arr[i] - arr[i - k];
        maxSoma = Math.Max(maxSoma, soma);
    }

    return maxSoma;
}
```

- **Entrada:** `[2,1,5,1,3,2], k=3`
- **SaÃ­da:** `9` (subarray `[5,1,3]`)

---

### ğŸ“ Exemplo 3 â€” Substring Mais Longa sem Caracteres Repetidos

```csharp
int LongestSubstringSemRepetir(string s) {
    var mapa = new Dictionary<char, int>();
    int inicio = 0, maxLen = 0;

    for (int fim = 0; fim < s.Length; fim++) {
        char c = s[fim];
        if (mapa.ContainsKey(c) && mapa[c] >= inicio)
            inicio = mapa[c] + 1;
        mapa[c] = fim;
        maxLen = Math.Max(maxLen, fim - inicio + 1);
    }

    return maxLen;
}
```

- **Entrada:** `"abcabcbb"`
- **SaÃ­da:** `3` (substring `"abc"`)
- **Complexidade:** O(n)

---

## ğŸ§© 3. Quando Usar Cada TÃ©cnica

| TÃ©cnica | Uso Ideal | Exemplo |
|----------|------------|----------|
| **Two Pointers** | Comparar ou mover Ã­ndices (arrays ordenados) | Remover duplicados, somas em pares |
| **Sliding Window** | Subarray ou substring contÃ­nua | Soma mÃ¡xima, janela sem repetiÃ§Ã£o |

---

## ğŸ’» 4. Exemplo PrÃ¡tico â€” Soma de Pares Igual a Alvo

```csharp
bool TemParComSoma(int[] arr, int alvo) {
    int i = 0, j = arr.Length - 1;
    Array.Sort(arr);

    while (i < j) {
        int soma = arr[i] + arr[j];
        if (soma == alvo) return true;
        else if (soma < alvo) i++;
        else j--;
    }

    return false;
}
```

**Entrada:** `[1, 4, 2, 7, 11, 15]`, alvo = 9  
**SaÃ­da:** `true` (2 + 7)

---

## ğŸ§© 5. ExercÃ­cios da Aula 04

**Ex 1.** Dado um array ordenado, remova os elementos duplicados in-place e retorne o novo comprimento.  
**Ex 2.** Dado um array e um valor `k`, encontre a maior soma de subarray contÃ­nuo de tamanho `k`.  
**Ex 3.** Dada uma string, encontre o tamanho da substring mais longa sem caracteres repetidos.  
**Ex 4.** Encontre todos os pares de nÃºmeros que somam um valor alvo.  
**Ex 5.** Dado um array binÃ¡rio (0 e 1), encontre o comprimento mÃ¡ximo de subarray com nÃºmero igual de 0s e 1s.

---

## ğŸ’ª 6. Desafio Extra â€” Subarray com Soma MÃ¡xima (Kadane)

```csharp
int MaxSubarray(int[] nums) {
    int maxAtual = nums[0];
    int maxGlobal = nums[0];
    for (int i = 1; i < nums.Length; i++) {
        maxAtual = Math.Max(nums[i], maxAtual + nums[i]);
        if (maxAtual > maxGlobal)
            maxGlobal = maxAtual;
    }
    return maxGlobal;
}
```

**Entrada:** `[-2,1,-3,4,-1,2,1,-5,4]`  
**SaÃ­da:** `6` (subarray `[4,-1,2,1]`)  
**Complexidade:** O(n)

---

## ğŸ§  7. Feynman â€” ExplicaÃ§Ã£o com Suas Palavras

Responda:
1. O que diferencia *Two Pointers* de *Sliding Window*?
2. Por que essas tÃ©cnicas sÃ£o mais eficientes que loops duplos?
3. Como a janela â€œdeslizaâ€ sobre o array?
4. Qual Ã© a relaÃ§Ã£o entre espaÃ§o e tempo nesses algoritmos?
5. DÃª um exemplo da vida real que usa o conceito de â€œjanela deslizanteâ€.

ğŸ“ Escreva suas respostas em atÃ© **150 palavras**.
