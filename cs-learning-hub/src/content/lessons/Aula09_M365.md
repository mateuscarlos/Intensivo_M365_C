# ğŸ“˜ Aula 09 â€” Algoritmos de OrdenaÃ§Ã£o e Busca (Sorting & Searching)

## ğŸ¯ Objetivos da Aula
- Entender os principais algoritmos de **ordenaÃ§Ã£o (sorting)** e **busca (searching)**.
- Compreender suas **complexidades de tempo e espaÃ§o**.
- Saber quando escolher cada tipo de algoritmo.
- Implementar soluÃ§Ãµes eficientes em C#.
- Aplicar tÃ©cnicas clÃ¡ssicas em cenÃ¡rios reais de entrevistas.

---

## ğŸ§  1. IntroduÃ§Ã£o

A ordenaÃ§Ã£o e a busca sÃ£o pilares da ciÃªncia da computaÃ§Ã£o.  
Quase todo problema de dados envolve **organizar e localizar informaÃ§Ãµes**.

ğŸ’¡ **Analogia Feynman:**  
Imagine uma pilha de cartas embaralhadas.  
VocÃª pode:
1. **OrdenÃ¡-las** (por nÃºmero/cor) â†’ *Sorting*  
2. **Procurar uma especÃ­fica** (como o Ãs de Copas) â†’ *Searching*

---

## â±ï¸ 2. Complexidade dos Algoritmos

| Algoritmo | Melhor Caso | MÃ©dio | Pior | Tipo |
|------------|--------------|--------|-------|------|
| **Bubble Sort** | O(n) | O(nÂ²) | O(nÂ²) | Comparativo |
| **Insertion Sort** | O(n) | O(nÂ²) | O(nÂ²) | Comparativo |
| **Merge Sort** | O(n log n) | O(n log n) | O(n log n) | DivisÃ£o e Conquista |
| **Quick Sort** | O(n log n) | O(n log n) | O(nÂ²) | DivisÃ£o e Conquista |
| **Binary Search** | O(1) | O(log n) | O(log n) | Busca binÃ¡ria |

---

## ğŸ§© 3. Bubble Sort â€” O mais simples

ğŸ’¡ **Ideia:** comparar pares adjacentes e trocar se estiverem fora de ordem.

```csharp
void BubbleSort(int[] arr) {
    for (int i = 0; i < arr.Length - 1; i++) {
        for (int j = 0; j < arr.Length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

**Entrada:** `[5, 3, 8, 4, 2]`  
**SaÃ­da:** `[2, 3, 4, 5, 8]`  

ğŸ“Š **Complexidade:** O(nÂ²)

---

## ğŸ§© 4. Insertion Sort â€” OrdenaÃ§Ã£o por inserÃ§Ã£o

ğŸ’¡ **Ideia:** percorre o array, â€œinserindoâ€ cada elemento na posiÃ§Ã£o correta do lado esquerdo jÃ¡ ordenado.

```csharp
void InsertionSort(int[] arr) {
    for (int i = 1; i < arr.Length; i++) {
        int chave = arr[i];
        int j = i - 1;

        while (j >= 0 && arr[j] > chave) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = chave;
    }
}
```

**Entrada:** `[5, 3, 4, 1, 2]`  
**SaÃ­da:** `[1, 2, 3, 4, 5]`

ğŸ“Š **Complexidade:** O(nÂ²), mas eficiente para listas pequenas.

---

## âš™ï¸ 5. Merge Sort â€” Dividir e Conquistar

ğŸ’¡ **Ideia:** divide o array em metades, ordena cada metade e as mescla (*merge*).

```csharp
void MergeSort(int[] arr, int esquerda, int direita) {
    if (esquerda < direita) {
        int meio = (esquerda + direita) / 2;
        MergeSort(arr, esquerda, meio);
        MergeSort(arr, meio + 1, direita);
        Merge(arr, esquerda, meio, direita);
    }
}

void Merge(int[] arr, int esquerda, int meio, int direita) {
    int[] temp = new int[direita - esquerda + 1];
    int i = esquerda, j = meio + 1, k = 0;

    while (i <= meio && j <= direita)
        temp[k++] = (arr[i] <= arr[j]) ? arr[i++] : arr[j++];

    while (i <= meio) temp[k++] = arr[i++];
    while (j <= direita) temp[k++] = arr[j++];

    for (k = 0; k < temp.Length; k++)
        arr[esquerda + k] = temp[k];
}
```

**Entrada:** `[38, 27, 43, 3, 9, 82, 10]`  
**SaÃ­da:** `[3, 9, 10, 27, 38, 43, 82]`

ğŸ“Š **Complexidade:** O(n log n)  
ğŸ’¾ **EspaÃ§o extra:** O(n)

---

## âš¡ 6. Quick Sort â€” O mais usado

ğŸ’¡ **Ideia:** escolhe um *pivÃ´*, separa os menores Ã  esquerda e os maiores Ã  direita, e repete o processo.

```csharp
void QuickSort(int[] arr, int inicio, int fim) {
    if (inicio < fim) {
        int pivo = Particionar(arr, inicio, fim);
        QuickSort(arr, inicio, pivo - 1);
        QuickSort(arr, pivo + 1, fim);
    }
}

int Particionar(int[] arr, int inicio, int fim) {
    int pivo = arr[fim];
    int i = inicio - 1;

    for (int j = inicio; j < fim; j++) {
        if (arr[j] < pivo) {
            i++;
            (arr[i], arr[j]) = (arr[j], arr[i]);
        }
    }

    (arr[i + 1], arr[fim]) = (arr[fim], arr[i + 1]);
    return i + 1;
}
```

**Entrada:** `[10, 7, 8, 9, 1, 5]`  
**SaÃ­da:** `[1, 5, 7, 8, 9, 10]`

ğŸ“Š **Complexidade MÃ©dia:** O(n log n)  
âš ï¸ **Pior caso (array ordenado):** O(nÂ²)

---

## ğŸ” 7. Busca Linear

ğŸ’¡ **Ideia:** percorre todos os elementos atÃ© encontrar o valor desejado.

```csharp
int BuscaLinear(int[] arr, int alvo) {
    for (int i = 0; i < arr.Length; i++)
        if (arr[i] == alvo)
            return i;
    return -1;
}
```

**Complexidade:** O(n)

---

## âš¡ 8. Busca BinÃ¡ria

ğŸ’¡ **Ideia:** busca eficiente **apenas em arrays ordenados**.  
Divide o espaÃ§o de busca ao meio a cada iteraÃ§Ã£o.

```csharp
int BuscaBinaria(int[] arr, int alvo) {
    int esquerda = 0, direita = arr.Length - 1;
    while (esquerda <= direita) {
        int meio = (esquerda + direita) / 2;
        if (arr[meio] == alvo) return meio;
        if (arr[meio] < alvo) esquerda = meio + 1;
        else direita = meio - 1;
    }
    return -1;
}
```

**Entrada:** `[1, 3, 5, 7, 9]`, alvo = `7`  
**SaÃ­da:** `Ã­ndice 3`

ğŸ“Š **Complexidade:** O(log n)

---

## ğŸ§© 9. ExercÃ­cios da Aula 09

**Ex 1.** Implemente o Bubble Sort e conte o nÃºmero de trocas realizadas.  
**Ex 2.** Use o Insertion Sort para ordenar uma lista de strings em ordem alfabÃ©tica.  
**Ex 3.** Aplique o Merge Sort em uma lista de 20 nÃºmeros aleatÃ³rios.  
**Ex 4.** Implemente a busca binÃ¡ria e teste com 10 valores diferentes.  
**Ex 5.** Compare o tempo de execuÃ§Ã£o do Quick Sort e do Merge Sort com 1.000 elementos.

---

## ğŸ’ª 10. Desafio Extra â€” Encontre o K-Ã©simo Maior Elemento

Implemente uma funÃ§Ã£o que encontre o **k-Ã©simo maior elemento** de um array **sem ordenar totalmente** (usando Quickselect).

```csharp
int QuickSelect(int[] arr, int esquerda, int direita, int k) {
    if (esquerda == direita) return arr[esquerda];

    int pivoIndex = Particionar(arr, esquerda, direita);
    int posicao = pivoIndex - esquerda + 1;

    if (posicao == k) return arr[pivoIndex];
    else if (k < posicao) return QuickSelect(arr, esquerda, pivoIndex - 1, k);
    else return QuickSelect(arr, pivoIndex + 1, direita, k - posicao);
}
```

**Entrada:** `[3,2,1,5,6,4]`, k = 2  
**SaÃ­da:** `5`

ğŸ“Š **Complexidade MÃ©dia:** O(n)

---

## ğŸ§  11. Feynman â€” ExplicaÃ§Ã£o com Suas Palavras

Responda:
1. Qual algoritmo Ã© mais rÃ¡pido em geral: Merge ou Quick Sort?
2. Por que a busca binÃ¡ria Ã© tÃ£o eficiente?
3. Quando usar Bubble Sort mesmo sendo lento?
4. Como a recursÃ£o Ã© usada no Merge e Quick Sort?
5. O que acontece se aplicar busca binÃ¡ria em um array nÃ£o ordenado?

ğŸ“ Escreva suas respostas em atÃ© **150 palavras**.
