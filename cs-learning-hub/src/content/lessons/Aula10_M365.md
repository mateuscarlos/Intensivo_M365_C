# ğŸ“˜ Aula 10 â€” ProgramaÃ§Ã£o DinÃ¢mica e Entrevista TÃ©cnica (Dynamic Programming & Mock Interview)

## ğŸ¯ Objetivos da Aula
- Compreender o conceito e a motivaÃ§Ã£o da **ProgramaÃ§Ã£o DinÃ¢mica (DP)**.
- Aprender a resolver problemas complexos por meio de **subproblemas** e **memorizaÃ§Ã£o**.
- Implementar algoritmos clÃ¡ssicos de DP em C#.
- Desenvolver raciocÃ­nio tÃ©cnico para entrevistas.
- Simular uma entrevista tÃ©cnica real com problemas Microsoft.

---

## ğŸ§  1. O Que Ã© ProgramaÃ§Ã£o DinÃ¢mica?

A **ProgramaÃ§Ã£o DinÃ¢mica (DP)** Ã© uma tÃ©cnica usada para resolver problemas **recorrentes** e **sobrepostos**, armazenando resultados de subproblemas para evitar recomputaÃ§Ã£o.

ğŸ’¡ **Analogia Feynman:**  
Imagine escalar uma escada de 100 degraus.  
VocÃª pode subir 1 ou 2 degraus por vez.  
Ao invÃ©s de recalcular todos os caminhos possÃ­veis a cada passo, vocÃª **lembra** quantas formas havia de chegar nos degraus anteriores.

---

## âš™ï¸ 2. Tipos de DP

| Tipo | DescriÃ§Ã£o | Exemplo |
|------|------------|----------|
| **Top-Down (MemorizaÃ§Ã£o)** | Usa recursÃ£o e guarda resultados jÃ¡ calculados. | Fibonacci recursivo com cache |
| **Bottom-Up (TabulaÃ§Ã£o)** | Usa laÃ§os para preencher uma tabela iterativamente. | Caminhos em grade (matriz) |

---

## ğŸ§© 3. Exemplo ClÃ¡ssico: Fibonacci

### ğŸ§® SoluÃ§Ã£o Recursiva (ineficiente)

```csharp
int Fib(int n) {
    if (n <= 1) return n;
    return Fib(n - 1) + Fib(n - 2);
}
```

ğŸ“Š **Complexidade:** O(2â¿)

---

### âš¡ SoluÃ§Ã£o com DP (Top-Down)

```csharp
Dictionary<int, int> memo = new Dictionary<int, int>();

int FibDP(int n) {
    if (n <= 1) return n;
    if (memo.ContainsKey(n)) return memo[n];

    memo[n] = FibDP(n - 1) + FibDP(n - 2);
    return memo[n];
}
```

ğŸ“Š **Complexidade:** O(n)

---

### ğŸ§® SoluÃ§Ã£o com DP (Bottom-Up)

```csharp
int FibTab(int n) {
    if (n <= 1) return n;
    int[] dp = new int[n + 1];
    dp[0] = 0; dp[1] = 1;

    for (int i = 2; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];

    return dp[n];
}
```

ğŸ“Š **Complexidade:** O(n)  
ğŸ’¾ **EspaÃ§o:** O(n)

---

## ğŸ’ 4. Problema da Mochila (Knapsack Problem)

**DescriÃ§Ã£o:** Dado um conjunto de itens com peso e valor, determine o valor mÃ¡ximo que pode ser carregado em uma mochila com capacidade limitada.

```csharp
int Mochila(int[] peso, int[] valor, int capacidade, int n) {
    if (n == 0 || capacidade == 0) return 0;

    if (peso[n - 1] > capacidade)
        return Mochila(peso, valor, capacidade, n - 1);

    else
        return Math.Max(
            valor[n - 1] + Mochila(peso, valor, capacidade - peso[n - 1], n - 1),
            Mochila(peso, valor, capacidade, n - 1)
        );
}
```

ğŸ“Š **Complexidade:** O(2â¿) (recursiva) â€” pode ser otimizada com DP.

---

### âš™ï¸ SoluÃ§Ã£o DP (Bottom-Up)

```csharp
int MochilaDP(int[] peso, int[] valor, int capacidade) {
    int n = peso.Length;
    int[,] dp = new int[n + 1, capacidade + 1];

    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= capacidade; w++) {
            if (i == 0 || w == 0)
                dp[i, w] = 0;
            else if (peso[i - 1] <= w)
                dp[i, w] = Math.Max(valor[i - 1] + dp[i - 1, w - peso[i - 1]], dp[i - 1, w]);
            else
                dp[i, w] = dp[i - 1, w];
        }
    }
    return dp[n, capacidade];
}
```

**Entrada:** pesos `[1,3,4,5]`, valores `[1,4,5,7]`, capacidade `7`  
**SaÃ­da:** `9`

---

## ğŸ§© 5. SubsequÃªncia Comum MÃ¡xima (LCS)

**DescriÃ§Ã£o:** Dadas duas strings, encontre o comprimento da maior subsequÃªncia comum.

```csharp
int LCS(string s1, string s2, int m, int n) {
    if (m == 0 || n == 0) return 0;

    if (s1[m - 1] == s2[n - 1])
        return 1 + LCS(s1, s2, m - 1, n - 1);
    else
        return Math.Max(LCS(s1, s2, m - 1, n), LCS(s1, s2, m, n - 1));
}
```

### ğŸ” SoluÃ§Ã£o DP (Bottom-Up)

```csharp
int LCS_DP(string s1, string s2) {
    int m = s1.Length, n = s2.Length;
    int[,] dp = new int[m + 1, n + 1];

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i - 1] == s2[j - 1])
                dp[i, j] = 1 + dp[i - 1, j - 1];
            else
                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
        }
    }
    return dp[m, n];
}
```

**Entrada:** `"ABCBDAB"` e `"BDCABA"`  
**SaÃ­da:** `4` (BCBA)

---

## ğŸ§© 6. ExercÃ­cios da Aula 10

**Ex 1.** Implemente Fibonacci usando DP (Top-Down e Bottom-Up).  
**Ex 2.** Resolva o problema da mochila com 5 itens e capacidade 10.  
**Ex 3.** Crie uma funÃ§Ã£o que conte o nÃºmero de formas de subir uma escada de `n` degraus (1 ou 2 por vez).  
**Ex 4.** Implemente o LCS para duas strings e exiba a subsequÃªncia resultante.  
**Ex 5.** Escreva uma funÃ§Ã£o DP para calcular o mÃ­nimo de moedas necessÃ¡rias para atingir um valor alvo.

---

## ğŸ’ª 7. Desafio Final â€” Mock Interview Microsoft

**Problema:**  
Dado um array de inteiros, encontre o **subarray contÃ­guo** com a **maior soma possÃ­vel**.

ğŸ’¡ **Dica:** Esse Ã© o **Algoritmo de Kadane**, clÃ¡ssico em entrevistas.

```csharp
int MaxSubArray(int[] nums) {
    int maxAtual = nums[0], maxTotal = nums[0];

    for (int i = 1; i < nums.Length; i++) {
        maxAtual = Math.Max(nums[i], maxAtual + nums[i]);
        maxTotal = Math.Max(maxTotal, maxAtual);
    }

    return maxTotal;
}
```

**Entrada:** `[-2,1,-3,4,-1,2,1,-5,4]`  
**SaÃ­da:** `6` (subarray `[4,-1,2,1]`)

ğŸ“Š **Complexidade:** O(n)

---

## ğŸ§  8. Feynman â€” ExplicaÃ§Ã£o com Suas Palavras

Responda:
1. O que Ã© ProgramaÃ§Ã£o DinÃ¢mica e quando aplicÃ¡-la?
2. Qual a diferenÃ§a entre memorizaÃ§Ã£o e tabulaÃ§Ã£o?
3. Por que DP Ã© mais eficiente que recursÃ£o simples?
4. Como o problema da mochila se aplica a decisÃµes reais?
5. Como vocÃª explicaria o algoritmo de Kadane a um colega?

ğŸ“ Escreva suas respostas em atÃ© **200 palavras**.

---

## ğŸ§­ ConclusÃ£o

ParabÃ©ns! ğŸ‰  
VocÃª completou o ciclo de preparaÃ§Ã£o intensiva para o teste tÃ©cnico da Microsoft M365.

A partir daqui:
- Pratique os problemas novamente no **HackerRank**.  
- Foque em **limpeza de cÃ³digo**, **nomes claros** e **explicaÃ§Ãµes curtas, mas completas**.  
- Lembre-se: o entrevistador avalia **como vocÃª pensa**, nÃ£o sÃ³ se acerta o cÃ³digo.

> âœ¨ â€œFirst, solve the problem. Then, write the code.â€ â€“ John Johnson
