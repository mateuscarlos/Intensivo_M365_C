# ğŸ“˜ Aula 05 â€” RecursÃ£o e Backtracking

## ğŸ¯ Objetivos da Aula
- Entender o conceito de **recursÃ£o** e como ela funciona internamente.
- Identificar **casos base** e **casos recursivos**.
- Compreender como o **backtracking** resolve problemas explorando caminhos possÃ­veis.
- Resolver problemas clÃ¡ssicos de recursÃ£o como *fatorial*, *Fibonacci* e *subconjuntos*.
- Analisar o custo computacional e os riscos (stack overflow).

---

## ğŸ§  1. O Que Ã© RecursÃ£o?

**RecursÃ£o** Ã© quando uma funÃ§Ã£o chama a si mesma para resolver subproblemas menores.

ğŸ’¡ **Analogia Feynman:**  
Pense em um espelho diante de outro espelho â€” a imagem se repete infinitamente, atÃ© que algo (o **caso base**) interrompe a repetiÃ§Ã£o.

---

### ğŸ“ Estrutura de uma FunÃ§Ã£o Recursiva

```csharp
Tipo NomeFuncao(Tipo parametro) {
    if (condicaoBase)
        return resultado; // Caso base
    else
        return NomeFuncao(novoParametro); // Chamada recursiva
}
```

Sem um **caso base**, a funÃ§Ã£o entrarÃ¡ em **loop infinito** atÃ© estourar a pilha (Stack Overflow).

---

## ğŸ§® 2. Exemplo 1 â€” Fatorial

```csharp
int Fatorial(int n) {
    if (n == 0) return 1;  // Caso base
    return n * Fatorial(n - 1); // Chamada recursiva
}
```

ğŸ“Š **ExecuÃ§Ã£o:**  
`Fatorial(4)` â†’ `4 * Fatorial(3)` â†’ `4 * 3 * Fatorial(2)` â†’ `4 * 3 * 2 * 1` â†’ `24`

---

## ğŸŒ€ 3. Exemplo 2 â€” Fibonacci

```csharp
int Fibonacci(int n) {
    if (n <= 1) return n;
    return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```

âš ï¸ **Cuidado:** essa versÃ£o Ã© **ineficiente** (complexidade O(2â¿)) â€” vÃ¡rias chamadas repetem os mesmos cÃ¡lculos.  
SoluÃ§Ãµes mais eficientes usam **memoizaÃ§Ã£o** ou **programaÃ§Ã£o dinÃ¢mica**.

---

## ğŸ§© 4. Exemplo 3 â€” Soma de Array

```csharp
int SomaArray(int[] arr, int n) {
    if (n == 0) return 0;
    return arr[n - 1] + SomaArray(arr, n - 1);
}
```

Entrada: `[1, 2, 3, 4]`  
SaÃ­da: `10`

---

## ğŸ§­ 5. IntroduÃ§Ã£o ao Backtracking

**Backtracking** Ã© uma forma de recursÃ£o que **explora todas as possibilidades** e â€œvolta atrÃ¡sâ€ quando uma escolha nÃ£o leva Ã  soluÃ§Ã£o.

ğŸ’¡ **Analogia Feynman:**  
Ã‰ como um labirinto: vocÃª tenta um caminho; se der errado, volta e tenta outro.

---

### ğŸ“ Exemplo 4 â€” GeraÃ§Ã£o de Subconjuntos

```csharp
void GeraSubconjuntos(List<int> atual, int[] nums, int i) {
    if (i == nums.Length) {
        Console.WriteLine(string.Join(", ", atual));
        return;
    }
    // Sem incluir o nÃºmero
    GeraSubconjuntos(atual, nums, i + 1);

    // Incluindo o nÃºmero
    atual.Add(nums[i]);
    GeraSubconjuntos(atual, nums, i + 1);
    atual.RemoveAt(atual.Count - 1); // Backtrack
}
```

Entrada: `[1,2]`  
SaÃ­da:
```
[]
[2]
[1]
[1,2]
```

---

### ğŸ“ Exemplo 5 â€” PermutaÃ§Ãµes de String

```csharp
void Permutacoes(string prefixo, string resto) {
    if (resto.Length == 0)
        Console.WriteLine(prefixo);
    else {
        for (int i = 0; i < resto.Length; i++) {
            string novoPrefixo = prefixo + resto[i];
            string novoResto = resto.Remove(i, 1);
            Permutacoes(novoPrefixo, novoResto);
        }
    }
}
```

Entrada: `"ABC"`  
SaÃ­da:
```
ABC
ACB
BAC
BCA
CAB
CBA
```

---

## ğŸ§© 6. ExercÃ­cios da Aula 05

**Ex 1.** Implemente uma funÃ§Ã£o recursiva para calcular o fatorial de `n`.  
**Ex 2.** Crie uma funÃ§Ã£o recursiva que some os nÃºmeros de 1 atÃ© `n`.  
**Ex 3.** Implemente Fibonacci de forma recursiva e conte o nÃºmero de chamadas.  
**Ex 4.** Escreva uma funÃ§Ã£o que gere todas as combinaÃ§Ãµes binÃ¡rias de um nÃºmero `n`.  
**Ex 5.** Gere todas as permutaÃ§Ãµes possÃ­veis de uma lista de inteiros.

---

## ğŸ’ª 7. Desafio Extra â€” N-Queens Simplificado

Coloque `n` rainhas em um tabuleiro `n x n` de modo que nenhuma ataque outra.

ğŸ’¡ Dica: use **backtracking** com:
- Uma funÃ§Ã£o recursiva que tenta colocar uma rainha em cada linha.
- Verifique se a posiÃ§Ã£o Ã© segura antes de seguir.
- â€œVolteâ€ (backtrack) se nÃ£o houver soluÃ§Ã£o possÃ­vel.

---

## ğŸ§  8. Feynman â€” ExplicaÃ§Ã£o com Suas Palavras

Responda:
1. Qual a diferenÃ§a entre recursÃ£o e iteraÃ§Ã£o?
2. Por que toda funÃ§Ã£o recursiva precisa de um caso base?
3. Como o backtracking â€œvolta atrÃ¡sâ€?
4. Cite um exemplo prÃ¡tico do dia a dia que pode ser resolvido por backtracking.
5. O que acontece se a recursÃ£o nÃ£o parar?

ğŸ“ Escreva suas respostas em atÃ© **150 palavras**.
