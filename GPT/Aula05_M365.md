# 📘 Aula 05 — Recursão e Backtracking

## 🎯 Objetivos da Aula
- Entender o conceito de **recursão** e como ela funciona internamente.
- Identificar **casos base** e **casos recursivos**.
- Compreender como o **backtracking** resolve problemas explorando caminhos possíveis.
- Resolver problemas clássicos de recursão como *fatorial*, *Fibonacci* e *subconjuntos*.
- Analisar o custo computacional e os riscos (stack overflow).

---

## 🧠 1. O Que é Recursão?

**Recursão** é quando uma função chama a si mesma para resolver subproblemas menores.

💡 **Analogia Feynman:**  
Pense em um espelho diante de outro espelho — a imagem se repete infinitamente, até que algo (o **caso base**) interrompe a repetição.

---

### 📍 Estrutura de uma Função Recursiva

```csharp
Tipo NomeFuncao(Tipo parametro) {
    if (condicaoBase)
        return resultado; // Caso base
    else
        return NomeFuncao(novoParametro); // Chamada recursiva
}
```

Sem um **caso base**, a função entrará em **loop infinito** até estourar a pilha (Stack Overflow).

---

## 🧮 2. Exemplo 1 — Fatorial

```csharp
int Fatorial(int n) {
    if (n == 0) return 1;  // Caso base
    return n * Fatorial(n - 1); // Chamada recursiva
}
```

📊 **Execução:**  
`Fatorial(4)` → `4 * Fatorial(3)` → `4 * 3 * Fatorial(2)` → `4 * 3 * 2 * 1` → `24`

---

## 🌀 3. Exemplo 2 — Fibonacci

```csharp
int Fibonacci(int n) {
    if (n <= 1) return n;
    return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```

⚠️ **Cuidado:** essa versão é **ineficiente** (complexidade O(2ⁿ)) — várias chamadas repetem os mesmos cálculos.  
Soluções mais eficientes usam **memoização** ou **programação dinâmica**.

---

## 🧩 4. Exemplo 3 — Soma de Array

```csharp
int SomaArray(int[] arr, int n) {
    if (n == 0) return 0;
    return arr[n - 1] + SomaArray(arr, n - 1);
}
```

Entrada: `[1, 2, 3, 4]`  
Saída: `10`

---

## 🧭 5. Introdução ao Backtracking

**Backtracking** é uma forma de recursão que **explora todas as possibilidades** e “volta atrás” quando uma escolha não leva à solução.

💡 **Analogia Feynman:**  
É como um labirinto: você tenta um caminho; se der errado, volta e tenta outro.

---

### 📍 Exemplo 4 — Geração de Subconjuntos

```csharp
void GeraSubconjuntos(List<int> atual, int[] nums, int i) {
    if (i == nums.Length) {
        Console.WriteLine(string.Join(", ", atual));
        return;
    }
    // Sem incluir o número
    GeraSubconjuntos(atual, nums, i + 1);

    // Incluindo o número
    atual.Add(nums[i]);
    GeraSubconjuntos(atual, nums, i + 1);
    atual.RemoveAt(atual.Count - 1); // Backtrack
}
```

Entrada: `[1,2]`  
Saída:
```
[]
[2]
[1]
[1,2]
```

---

### 📍 Exemplo 5 — Permutações de String

```csharp
void Permutacoes(string prefixo, string resto) {
    if (resto.Length == 0)
        Console.WriteLine(prefixo);
    else {
        for (int i = 0; i < resto.Length; i++) {
            string novoPrefixo = prefixo + resto[i];
            string novoResto = resto.Remove(i, 1);
            Permutacoes(novoPrefixo, novoResto);
        }
    }
}
```

Entrada: `"ABC"`  
Saída:
```
ABC
ACB
BAC
BCA
CAB
CBA
```

---

## 🧩 6. Exercícios da Aula 05

**Ex 1.** Implemente uma função recursiva para calcular o fatorial de `n`.  
**Ex 2.** Crie uma função recursiva que some os números de 1 até `n`.  
**Ex 3.** Implemente Fibonacci de forma recursiva e conte o número de chamadas.  
**Ex 4.** Escreva uma função que gere todas as combinações binárias de um número `n`.  
**Ex 5.** Gere todas as permutações possíveis de uma lista de inteiros.

---

## 💪 7. Desafio Extra — N-Queens Simplificado

Coloque `n` rainhas em um tabuleiro `n x n` de modo que nenhuma ataque outra.

💡 Dica: use **backtracking** com:
- Uma função recursiva que tenta colocar uma rainha em cada linha.
- Verifique se a posição é segura antes de seguir.
- “Volte” (backtrack) se não houver solução possível.

---

## 🧠 8. Feynman — Explicação com Suas Palavras

Responda:
1. Qual a diferença entre recursão e iteração?
2. Por que toda função recursiva precisa de um caso base?
3. Como o backtracking “volta atrás”?
4. Cite um exemplo prático do dia a dia que pode ser resolvido por backtracking.
5. O que acontece se a recursão não parar?

📝 Escreva suas respostas em até **150 palavras**.
