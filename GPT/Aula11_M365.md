# ğŸ“˜ Aula 11 â€” Estruturas AvanÃ§adas e AnÃ¡lise de Complexidade

## ğŸ¯ Objetivos da Aula
- Compreender e aplicar estruturas de dados avanÃ§adas: **HashSet**, **Dictionary**, **Heap** (fila de prioridade).
- Entender o conceito de **tabela de dispersÃ£o (hash table)** e funÃ§Ãµes hash.
- Representar e manipular **grafos** (listas de adjacÃªncia e matriz de adjacÃªncia).
- Analisar **complexidade de tempo e espaÃ§o** (Big O).
- Resolver exercÃ­cios com foco em otimizaÃ§Ã£o e anÃ¡lise.

---

## ğŸ§  1. RevisÃ£o de Complexidade (Big O)

| OperaÃ§Ã£o | Exemplo | Complexidade |
|-----------|----------|---------------|
| Acesso direto | Array[i] | O(1) |
| Busca linear | foreach | O(n) |
| Busca binÃ¡ria | Array ordenado | O(log n) |
| InserÃ§Ã£o/remover em HashSet | O(1) mÃ©dio |
| OrdenaÃ§Ã£o (QuickSort, MergeSort) | O(n log n) |
| DFS/BFS em grafo | O(V + E) |

ğŸ“˜ **Lembre:**  
- O(1): tempo constante.  
- O(n): tempo proporcional ao tamanho dos dados.  
- O(nÂ²): tempo quadrÃ¡tico (crescimento rÃ¡pido).

---

## âš™ï¸ 2. HashSet e Dictionary

### ğŸ§© HashSet
Uma estrutura que **armazenar valores Ãºnicos** e permite buscas rÃ¡pidas.

```csharp
var set = new HashSet<int>();
set.Add(10);
set.Add(20);
set.Add(10); // ignorado

Console.WriteLine(set.Contains(20)); // true
```

**Complexidade mÃ©dia:**  
- InserÃ§Ã£o: O(1)  
- Busca: O(1)

---

### ğŸ“’ Dictionary<TKey, TValue>
Permite armazenar pares **chave â†’ valor**.

```csharp
var dict = new Dictionary<string, int>();
dict["Alice"] = 25;
dict["Bob"] = 30;

foreach (var kv in dict)
    Console.WriteLine($"{kv.Key} tem {kv.Value} anos");
```

ğŸ§® **FunÃ§Ã£o hash:**  
O Dictionary calcula um *hash code* da chave para armazenar rapidamente o valor.

---

## ğŸ—ï¸ 3. Heap (Priority Queue)

### ğŸ“¦ O que Ã©
Uma estrutura que mantÃ©m sempre o **menor (ou maior) elemento no topo**.

```csharp
var pq = new PriorityQueue<string, int>();
pq.Enqueue("Tarefa baixa", 3);
pq.Enqueue("Tarefa alta", 1);
pq.Enqueue("Tarefa mÃ©dia", 2);

while (pq.Count > 0)
    Console.WriteLine(pq.Dequeue()); // ordem: alta, mÃ©dia, baixa
```

ğŸ“Š **Complexidade:**  
- InserÃ§Ã£o: O(log n)  
- RemoÃ§Ã£o (Dequeue): O(log n)

---

## ğŸ•¸ï¸ 4. Grafos

### ğŸŒ RepresentaÃ§Ã£o com Lista de AdjacÃªncia
```csharp
var grafo = new Dictionary<int, List<int>> {
    [0] = new List<int> {1, 2},
    [1] = new List<int> {2},
    [2] = new List<int> {0, 3},
    [3] = new List<int> {3}
};
```

### ğŸ” Busca em Largura (BFS)
```csharp
void BFS(Dictionary<int, List<int>> g, int inicio) {
    var visitado = new HashSet<int>();
    var fila = new Queue<int>();
    fila.Enqueue(inicio);

    while (fila.Count > 0) {
        int v = fila.Dequeue();
        if (!visitado.Add(v)) continue;
        Console.WriteLine($"Visitando: {v}");
        foreach (var viz in g[v]) fila.Enqueue(viz);
    }
}
```

### ğŸ§­ Busca em Profundidade (DFS)
```csharp
void DFS(Dictionary<int, List<int>> g, int v, HashSet<int> vis) {
    if (vis.Contains(v)) return;
    vis.Add(v);
    Console.WriteLine($"Visitando: {v}");
    foreach (var viz in g[v]) DFS(g, viz, vis);
}
```

---

## ğŸ§© 5. AnÃ¡lise de Complexidade na PrÃ¡tica

### Exemplo 1 â€” Busca Linear
```csharp
bool Encontrar(int[] arr, int alvo) {
    foreach (var x in arr)
        if (x == alvo) return true;
    return false;
}
```
â±ï¸ O(n)

### Exemplo 2 â€” Busca BinÃ¡ria
```csharp
bool BuscaBinaria(int[] arr, int alvo) {
    int ini = 0, fim = arr.Length - 1;
    while (ini <= fim) {
        int mid = (ini + fim) / 2;
        if (arr[mid] == alvo) return true;
        if (arr[mid] < alvo) ini = mid + 1;
        else fim = mid - 1;
    }
    return false;
}
```
â±ï¸ O(log n)

---

## ğŸ§© 6. ExercÃ­cios da Aula 11

**Ex 1.** Crie um `HashSet<string>` para armazenar nomes Ãºnicos de alunos e mostre todos ordenados alfabeticamente.  
**Ex 2.** Use um `Dictionary<string, int>` para contar quantas vezes cada palavra aparece em uma frase.  
**Ex 3.** Implemente uma fila de prioridade de tarefas com nomes e prioridades.  
**Ex 4.** Represente um grafo simples e implemente DFS e BFS.  
**Ex 5.** Compare empiricamente o tempo de busca em uma `List<int>` e em um `HashSet<int>` para 1 milhÃ£o de elementos.

---

## ğŸ§  7. Feynman â€” ExplicaÃ§Ã£o com Suas Palavras

1. O que Ã© uma funÃ§Ã£o hash e como ela afeta a performance de um `Dictionary`?  
2. Qual a diferenÃ§a entre HashSet e List?  
3. Quando Ã© vantajoso usar uma fila de prioridade?  
4. Como a BFS e a DFS exploram os grafos de maneiras diferentes?  
5. Qual a diferenÃ§a prÃ¡tica entre O(log n) e O(n)?  

ğŸ“ Escreva suas respostas e explique como se estivesse ensinando a um colega.

---

## ğŸ§­ ConclusÃ£o

VocÃª agora domina as estruturas fundamentais usadas em sistemas reais e entrevistas tÃ©cnicas.  
Esses conceitos sÃ£o essenciais para lidar com performance, otimizaÃ§Ã£o e arquitetura eficiente.

> âš¡ **Dica Microsoft:** Dominar estruturas de dados Ã© dominar o tempo. O cÃ³digo mais rÃ¡pido Ã© aquele que entende o problema.
