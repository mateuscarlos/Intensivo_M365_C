# 📘 Aula 11 — Estruturas Avançadas e Análise de Complexidade

## 🎯 Objetivos da Aula
- Compreender e aplicar estruturas de dados avançadas: **HashSet**, **Dictionary**, **Heap** (fila de prioridade).
- Entender o conceito de **tabela de dispersão (hash table)** e funções hash.
- Representar e manipular **grafos** (listas de adjacência e matriz de adjacência).
- Analisar **complexidade de tempo e espaço** (Big O).
- Resolver exercícios com foco em otimização e análise.

---

## 🧠 1. Revisão de Complexidade (Big O)

| Operação | Exemplo | Complexidade |
|-----------|----------|---------------|
| Acesso direto | Array[i] | O(1) |
| Busca linear | foreach | O(n) |
| Busca binária | Array ordenado | O(log n) |
| Inserção/remover em HashSet | O(1) médio |
| Ordenação (QuickSort, MergeSort) | O(n log n) |
| DFS/BFS em grafo | O(V + E) |

📘 **Lembre:**  
- O(1): tempo constante.  
- O(n): tempo proporcional ao tamanho dos dados.  
- O(n²): tempo quadrático (crescimento rápido).

---

## ⚙️ 2. HashSet e Dictionary

### 🧩 HashSet
Uma estrutura que **armazenar valores únicos** e permite buscas rápidas.

```csharp
var set = new HashSet<int>();
set.Add(10);
set.Add(20);
set.Add(10); // ignorado

Console.WriteLine(set.Contains(20)); // true
```

**Complexidade média:**  
- Inserção: O(1)  
- Busca: O(1)

---

### 📒 Dictionary<TKey, TValue>
Permite armazenar pares **chave → valor**.

```csharp
var dict = new Dictionary<string, int>();
dict["Alice"] = 25;
dict["Bob"] = 30;

foreach (var kv in dict)
    Console.WriteLine($"{kv.Key} tem {kv.Value} anos");
```

🧮 **Função hash:**  
O Dictionary calcula um *hash code* da chave para armazenar rapidamente o valor.

---

## 🏗️ 3. Heap (Priority Queue)

### 📦 O que é
Uma estrutura que mantém sempre o **menor (ou maior) elemento no topo**.

```csharp
var pq = new PriorityQueue<string, int>();
pq.Enqueue("Tarefa baixa", 3);
pq.Enqueue("Tarefa alta", 1);
pq.Enqueue("Tarefa média", 2);

while (pq.Count > 0)
    Console.WriteLine(pq.Dequeue()); // ordem: alta, média, baixa
```

📊 **Complexidade:**  
- Inserção: O(log n)  
- Remoção (Dequeue): O(log n)

---

## 🕸️ 4. Grafos

### 🌐 Representação com Lista de Adjacência
```csharp
var grafo = new Dictionary<int, List<int>> {
    [0] = new List<int> {1, 2},
    [1] = new List<int> {2},
    [2] = new List<int> {0, 3},
    [3] = new List<int> {3}
};
```

### 🔍 Busca em Largura (BFS)
```csharp
void BFS(Dictionary<int, List<int>> g, int inicio) {
    var visitado = new HashSet<int>();
    var fila = new Queue<int>();
    fila.Enqueue(inicio);

    while (fila.Count > 0) {
        int v = fila.Dequeue();
        if (!visitado.Add(v)) continue;
        Console.WriteLine($"Visitando: {v}");
        foreach (var viz in g[v]) fila.Enqueue(viz);
    }
}
```

### 🧭 Busca em Profundidade (DFS)
```csharp
void DFS(Dictionary<int, List<int>> g, int v, HashSet<int> vis) {
    if (vis.Contains(v)) return;
    vis.Add(v);
    Console.WriteLine($"Visitando: {v}");
    foreach (var viz in g[v]) DFS(g, viz, vis);
}
```

---

## 🧩 5. Análise de Complexidade na Prática

### Exemplo 1 — Busca Linear
```csharp
bool Encontrar(int[] arr, int alvo) {
    foreach (var x in arr)
        if (x == alvo) return true;
    return false;
}
```
⏱️ O(n)

### Exemplo 2 — Busca Binária
```csharp
bool BuscaBinaria(int[] arr, int alvo) {
    int ini = 0, fim = arr.Length - 1;
    while (ini <= fim) {
        int mid = (ini + fim) / 2;
        if (arr[mid] == alvo) return true;
        if (arr[mid] < alvo) ini = mid + 1;
        else fim = mid - 1;
    }
    return false;
}
```
⏱️ O(log n)

---

## 🧩 6. Exercícios da Aula 11

**Ex 1.** Crie um `HashSet<string>` para armazenar nomes únicos de alunos e mostre todos ordenados alfabeticamente.  
**Ex 2.** Use um `Dictionary<string, int>` para contar quantas vezes cada palavra aparece em uma frase.  
**Ex 3.** Implemente uma fila de prioridade de tarefas com nomes e prioridades.  
**Ex 4.** Represente um grafo simples e implemente DFS e BFS.  
**Ex 5.** Compare empiricamente o tempo de busca em uma `List<int>` e em um `HashSet<int>` para 1 milhão de elementos.

---

## 🧠 7. Feynman — Explicação com Suas Palavras

1. O que é uma função hash e como ela afeta a performance de um `Dictionary`?  
2. Qual a diferença entre HashSet e List?  
3. Quando é vantajoso usar uma fila de prioridade?  
4. Como a BFS e a DFS exploram os grafos de maneiras diferentes?  
5. Qual a diferença prática entre O(log n) e O(n)?  

📝 Escreva suas respostas e explique como se estivesse ensinando a um colega.

---

## 🧭 Conclusão

Você agora domina as estruturas fundamentais usadas em sistemas reais e entrevistas técnicas.  
Esses conceitos são essenciais para lidar com performance, otimização e arquitetura eficiente.

> ⚡ **Dica Microsoft:** Dominar estruturas de dados é dominar o tempo. O código mais rápido é aquele que entende o problema.
