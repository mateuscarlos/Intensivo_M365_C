# 📘 Aula 04 — Two Pointers e Sliding Window

## 🎯 Objetivos da Aula
- Entender o conceito de **Two Pointers** e **Sliding Window**.
- Resolver problemas clássicos de arrays e strings com eficiência.
- Reduzir complexidade de O(n²) para O(n).
- Aplicar lógica de movimentação simultânea de ponteiros.
- Desenvolver soluções otimizadas no estilo **HackerRank/LeetCode**.

---

## 🧠 1. Conceito de Two Pointers

A técnica **Two Pointers (dois ponteiros)** usa duas variáveis (índices) que percorrem uma estrutura ao mesmo tempo.

💡 **Analogia Feynman:** imagine duas pessoas caminhando em uma estrada (array):
- Uma anda rápido (ponteiro direito);
- Outra anda devagar (ponteiro esquerdo);
- Elas se aproximam, se afastam ou percorrem a estrada para encontrar um padrão.

---

### 📍 Exemplo 1 — Remover Duplicados em Array Ordenado

```csharp
int RemoveDuplicados(int[] nums) {
    if (nums.Length == 0) return 0;
    int i = 0;
    for (int j = 1; j < nums.Length; j++) {
        if (nums[j] != nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}
```

- **Entrada:** `[1,1,2,2,3]`
- **Saída:** `3` (Array final: `[1,2,3,_,_]`)
- **Complexidade:** O(n)

---

## 🧮 2. Conceito de Sliding Window

A técnica **Sliding Window (janela deslizante)** mantém uma *subestrutura contínua* dentro de uma sequência.
A janela se expande ou contrai conforme a condição do problema.

💡 **Analogia:**  
Pense em uma janela de vidro deslizando sobre uma linha de números — você vê apenas uma parte da sequência de cada vez.

---

### 📍 Exemplo 2 — Maior Soma de Subarray de Tamanho Fixo K

```csharp
int MaxSomaSubarray(int[] arr, int k) {
    int soma = 0, maxSoma = 0;

    for (int i = 0; i < k; i++)
        soma += arr[i];
    maxSoma = soma;

    for (int i = k; i < arr.Length; i++) {
        soma += arr[i] - arr[i - k];
        maxSoma = Math.Max(maxSoma, soma);
    }

    return maxSoma;
}
```

- **Entrada:** `[2,1,5,1,3,2], k=3`
- **Saída:** `9` (subarray `[5,1,3]`)

---

### 📍 Exemplo 3 — Substring Mais Longa sem Caracteres Repetidos

```csharp
int LongestSubstringSemRepetir(string s) {
    var mapa = new Dictionary<char, int>();
    int inicio = 0, maxLen = 0;

    for (int fim = 0; fim < s.Length; fim++) {
        char c = s[fim];
        if (mapa.ContainsKey(c) && mapa[c] >= inicio)
            inicio = mapa[c] + 1;
        mapa[c] = fim;
        maxLen = Math.Max(maxLen, fim - inicio + 1);
    }

    return maxLen;
}
```

- **Entrada:** `"abcabcbb"`
- **Saída:** `3` (substring `"abc"`)
- **Complexidade:** O(n)

---

## 🧩 3. Quando Usar Cada Técnica

| Técnica | Uso Ideal | Exemplo |
|----------|------------|----------|
| **Two Pointers** | Comparar ou mover índices (arrays ordenados) | Remover duplicados, somas em pares |
| **Sliding Window** | Subarray ou substring contínua | Soma máxima, janela sem repetição |

---

## 💻 4. Exemplo Prático — Soma de Pares Igual a Alvo

```csharp
bool TemParComSoma(int[] arr, int alvo) {
    int i = 0, j = arr.Length - 1;
    Array.Sort(arr);

    while (i < j) {
        int soma = arr[i] + arr[j];
        if (soma == alvo) return true;
        else if (soma < alvo) i++;
        else j--;
    }

    return false;
}
```

**Entrada:** `[1, 4, 2, 7, 11, 15]`, alvo = 9  
**Saída:** `true` (2 + 7)

---

## 🧩 5. Exercícios da Aula 04

**Ex 1.** Dado um array ordenado, remova os elementos duplicados in-place e retorne o novo comprimento.  
**Ex 2.** Dado um array e um valor `k`, encontre a maior soma de subarray contínuo de tamanho `k`.  
**Ex 3.** Dada uma string, encontre o tamanho da substring mais longa sem caracteres repetidos.  
**Ex 4.** Encontre todos os pares de números que somam um valor alvo.  
**Ex 5.** Dado um array binário (0 e 1), encontre o comprimento máximo de subarray com número igual de 0s e 1s.

---

## 💪 6. Desafio Extra — Subarray com Soma Máxima (Kadane)

```csharp
int MaxSubarray(int[] nums) {
    int maxAtual = nums[0];
    int maxGlobal = nums[0];
    for (int i = 1; i < nums.Length; i++) {
        maxAtual = Math.Max(nums[i], maxAtual + nums[i]);
        if (maxAtual > maxGlobal)
            maxGlobal = maxAtual;
    }
    return maxGlobal;
}
```

**Entrada:** `[-2,1,-3,4,-1,2,1,-5,4]`  
**Saída:** `6` (subarray `[4,-1,2,1]`)  
**Complexidade:** O(n)

---

## 🧠 7. Feynman — Explicação com Suas Palavras

Responda:
1. O que diferencia *Two Pointers* de *Sliding Window*?
2. Por que essas técnicas são mais eficientes que loops duplos?
3. Como a janela “desliza” sobre o array?
4. Qual é a relação entre espaço e tempo nesses algoritmos?
5. Dê um exemplo da vida real que usa o conceito de “janela deslizante”.

📝 Escreva suas respostas em até **150 palavras**.
