# üéØ Aula 12 ‚Äî Simula√ß√£o Completa de Entrevista T√©cnica (Mock Interview Microsoft)

## üß≠ Objetivos da Aula
- Simular uma entrevista t√©cnica real para vaga de **Software Engineer M365 (Microsoft)**.
- Consolidar conceitos de **algoritmos, estruturas de dados e design de sistemas**.
- Praticar **racioc√≠nio, comunica√ß√£o e explica√ß√£o do c√≥digo** durante o processo.
- Aplicar o **m√©todo Feynman** para revisar e fixar o conhecimento.

---

## üß† 1. Estrutura de uma Entrevista T√©cnica

As entrevistas t√©cnicas da Microsoft seguem um formato padronizado:

| Etapa | Descri√ß√£o |
|-------|------------|
| **Introdu√ß√£o (5 min)** | O entrevistador se apresenta e pede para voc√™ se apresentar brevemente. |
| **Problema t√©cnico (30-40 min)** | Um ou dois desafios de codifica√ß√£o s√£o apresentados. |
| **Discuss√£o (10-15 min)** | O entrevistador analisa sua abordagem, complexidade e clareza. |
| **Perguntas finais (5 min)** | Voc√™ pode fazer perguntas sobre a equipe e o projeto. |

üó£Ô∏è **O que eles avaliam:**
1. Capacidade de **racioc√≠nio l√≥gico** e **estruturar o problema**.  
2. Clareza na **comunica√ß√£o e justificativa das decis√µes**.  
3. C√≥digo limpo, modular e eficiente.  
4. Entendimento de **trade-offs de performance**.

---

## ‚öôÔ∏è 2. Estrat√©gia de Resolu√ß√£o (M√©todo Microsoft)

1. **Ou√ßa e reformule o problema** com suas palavras.  
2. **Defina entradas e sa√≠das** claramente.  
3. **Proponha exemplos e casos de teste.**  
4. **Explique a abordagem** antes de come√ßar a codar.  
5. **Implemente passo a passo**, validando resultados.  
6. **Analise a complexidade** (tempo e espa√ßo).  
7. **Refatore se houver tempo.**

---

## üí° 3. Problemas F√°ceis (Aquecimento)

### Ex 1 ‚Äî Inverter uma string
Implemente uma fun√ß√£o que inverte uma string sem usar m√©todos prontos.

```csharp
string Inverter(string s) {
    char[] arr = s.ToCharArray();
    Array.Reverse(arr);
    return new string(arr);
}
```

**Perguntas poss√≠veis do entrevistador:**
- Como ficaria se a string fosse muito grande?
- O que muda se voc√™ quiser inverter as palavras e n√£o os caracteres?

---

### Ex 2 ‚Äî Soma de pares com alvo
Dado um array de inteiros e um valor alvo, retorne os pares cuja soma seja igual ao alvo.

```csharp
int[] nums = {2, 7, 11, 15};
int alvo = 9;
// resultado: [2, 7]
```

**Dica:** Use um HashSet para obter O(n) de tempo.

---

## ‚öîÔ∏è 4. Problemas Intermedi√°rios

### Ex 3 ‚Äî Substring mais longa sem repeti√ß√£o
```csharp
int LongestSubstring(string s) {
    var mapa = new Dictionary<char, int>();
    int inicio = 0, max = 0;
    for (int i = 0; i < s.Length; i++) {
        if (mapa.ContainsKey(s[i]) && mapa[s[i]] >= inicio)
            inicio = mapa[s[i]] + 1;
        mapa[s[i]] = i;
        max = Math.Max(max, i - inicio + 1);
    }
    return max;
}
```

üìä Complexidade: O(n)

**Perguntas:**
- Qual √© o trade-off entre usar um dicion√°rio e um array fixo de 128 posi√ß√µes?  
- Como adaptar para Unicode completo?

---

### Ex 4 ‚Äî Mesclar intervalos
Dada uma lista de intervalos `[in√≠cio, fim]`, una os sobrepostos.

```csharp
List<(int, int)> Mesclar(List<(int, int)> intervals) {
    intervals.Sort((a, b) => a.Item1.CompareTo(b.Item1));
    var res = new List<(int, int)> { intervals[0] };
    foreach (var cur in intervals.Skip(1)) {
        var last = res[^1];
        if (cur.Item1 <= last.Item2)
            res[^1] = (last.Item1, Math.Max(last.Item2, cur.Item2));
        else
            res.Add(cur);
    }
    return res;
}
```

**Pergunta:** Como otimizar se os intervalos j√° estiverem ordenados?

---

## üß© 5. Problemas Avan√ßados (Microsoft-level)

### Ex 5 ‚Äî Caminho m√≠nimo em um grafo (BFS)
```csharp
int BFSMinSteps(Dictionary<int, List<int>> g, int inicio, int destino) {
    var fila = new Queue<(int, int)>(); // n√≥, passos
    var visitado = new HashSet<int>();
    fila.Enqueue((inicio, 0));

    while (fila.Count > 0) {
        var (v, dist) = fila.Dequeue();
        if (v == destino) return dist;
        if (!visitado.Add(v)) continue;
        foreach (var viz in g[v]) fila.Enqueue((viz, dist + 1));
    }
    return -1;
}
```

**Discuss√£o:**  
- Qual √© a complexidade de tempo e espa√ßo?  
- Quando seria melhor usar Dijkstra?

---

### Ex 6 ‚Äî Subconjunto de soma alvo (Programa√ß√£o Din√¢mica)
```csharp
bool SubsetSum(int[] nums, int alvo) {
    bool[,] dp = new bool[nums.Length + 1, alvo + 1];
    for (int i = 0; i <= nums.Length; i++) dp[i, 0] = true;

    for (int i = 1; i <= nums.Length; i++) {
        for (int j = 1; j <= alvo; j++) {
            dp[i, j] = dp[i - 1, j];
            if (j >= nums[i - 1])
                dp[i, j] = dp[i, j] || dp[i - 1, j - nums[i - 1]];
        }
    }
    return dp[nums.Length, alvo];
}
```

**Pergunta:** Como otimizar o espa√ßo da matriz DP?

---

## üß© 6. Simula√ß√£o de Entrevista Completa (Mock Microsoft)

**Situa√ß√£o:** Voc√™ √© convidado a resolver o seguinte problema durante 40 minutos.

> **Problema:** Dado um conjunto de palavras, encontre todas as combina√ß√µes que formam anagramas.

**Exemplo:**
```text
Entrada: ["bat", "tab", "tap", "pat", "cat"]
Sa√≠da: [["bat", "tab"], ["tap", "pat"], ["cat"]]
```

**Racioc√≠nio:**
1. Duas palavras s√£o anagramas se tiverem as mesmas letras ordenadas.  
2. Podemos agrupar palavras por sua forma ordenada (`key`).  

**Implementa√ß√£o:**
```csharp
List<List<string>> AgruparAnagramas(string[] palavras) {
    var grupos = new Dictionary<string, List<string>>();
    foreach (var p in palavras) {
        var key = new string(p.OrderBy(c => c).ToArray());
        if (!grupos.ContainsKey(key)) grupos[key] = new List<string>();
        grupos[key].Add(p);
    }
    return grupos.Values.ToList();
}
```

**Discuss√£o:**
- Complexidade de tempo: O(n * m log m)  
  (n = n√∫mero de palavras, m = tamanho m√©dio de cada palavra)

---

## üß† 7. Feynman ‚Äî Explique o que Voc√™ Aprendeu

1. Como voc√™ definiria a abordagem para um problema novo?  
2. Quais s√£o as etapas principais de racioc√≠nio antes de codar?  
3. Como explicar a complexidade de um algoritmo sem parecer decorado?  
4. Como se manter calmo e anal√≠tico sob press√£o?  
5. O que faria diferente em uma pr√≥xima entrevista?

üßæ Escreva suas respostas, como se estivesse ensinando algu√©m.

---

## üß≠ Conclus√£o

üéì Parab√©ns! Voc√™ completou o programa de prepara√ß√£o para o processo seletivo **Microsoft 365**.  
Voc√™ agora possui:  
- Fundamentos s√≥lidos em C# e .NET.  
- Entendimento profundo de algoritmos e estruturas de dados.  
- Experi√™ncia simulada em entrevistas t√©cnicas reais.  

> ‚Äú**Grandes engenheiros n√£o memorizam solu√ß√µes, entendem problemas.**‚Äù ‚Äî Bill Gates

---

üöÄ **Pr√≥ximo passo:** revise seus c√≥digos, pratique desafios no HackerRank e refine sua comunica√ß√£o t√©cnica.
