# 📘 Aula 09 — Algoritmos de Ordenação e Busca (Sorting & Searching)

## 🎯 Objetivos da Aula
- Entender os principais algoritmos de **ordenação (sorting)** e **busca (searching)**.
- Compreender suas **complexidades de tempo e espaço**.
- Saber quando escolher cada tipo de algoritmo.
- Implementar soluções eficientes em C#.
- Aplicar técnicas clássicas em cenários reais de entrevistas.

---

## 🧠 1. Introdução

A ordenação e a busca são pilares da ciência da computação.  
Quase todo problema de dados envolve **organizar e localizar informações**.

💡 **Analogia Feynman:**  
Imagine uma pilha de cartas embaralhadas.  
Você pode:
1. **Ordená-las** (por número/cor) → *Sorting*  
2. **Procurar uma específica** (como o Ás de Copas) → *Searching*

---

## ⏱️ 2. Complexidade dos Algoritmos

| Algoritmo | Melhor Caso | Médio | Pior | Tipo |
|------------|--------------|--------|-------|------|
| **Bubble Sort** | O(n) | O(n²) | O(n²) | Comparativo |
| **Insertion Sort** | O(n) | O(n²) | O(n²) | Comparativo |
| **Merge Sort** | O(n log n) | O(n log n) | O(n log n) | Divisão e Conquista |
| **Quick Sort** | O(n log n) | O(n log n) | O(n²) | Divisão e Conquista |
| **Binary Search** | O(1) | O(log n) | O(log n) | Busca binária |

---

## 🧩 3. Bubble Sort — O mais simples

💡 **Ideia:** comparar pares adjacentes e trocar se estiverem fora de ordem.

```csharp
void BubbleSort(int[] arr) {
    for (int i = 0; i < arr.Length - 1; i++) {
        for (int j = 0; j < arr.Length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

**Entrada:** `[5, 3, 8, 4, 2]`  
**Saída:** `[2, 3, 4, 5, 8]`  

📊 **Complexidade:** O(n²)

---

## 🧩 4. Insertion Sort — Ordenação por inserção

💡 **Ideia:** percorre o array, “inserindo” cada elemento na posição correta do lado esquerdo já ordenado.

```csharp
void InsertionSort(int[] arr) {
    for (int i = 1; i < arr.Length; i++) {
        int chave = arr[i];
        int j = i - 1;

        while (j >= 0 && arr[j] > chave) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = chave;
    }
}
```

**Entrada:** `[5, 3, 4, 1, 2]`  
**Saída:** `[1, 2, 3, 4, 5]`

📊 **Complexidade:** O(n²), mas eficiente para listas pequenas.

---

## ⚙️ 5. Merge Sort — Dividir e Conquistar

💡 **Ideia:** divide o array em metades, ordena cada metade e as mescla (*merge*).

```csharp
void MergeSort(int[] arr, int esquerda, int direita) {
    if (esquerda < direita) {
        int meio = (esquerda + direita) / 2;
        MergeSort(arr, esquerda, meio);
        MergeSort(arr, meio + 1, direita);
        Merge(arr, esquerda, meio, direita);
    }
}

void Merge(int[] arr, int esquerda, int meio, int direita) {
    int[] temp = new int[direita - esquerda + 1];
    int i = esquerda, j = meio + 1, k = 0;

    while (i <= meio && j <= direita)
        temp[k++] = (arr[i] <= arr[j]) ? arr[i++] : arr[j++];

    while (i <= meio) temp[k++] = arr[i++];
    while (j <= direita) temp[k++] = arr[j++];

    for (k = 0; k < temp.Length; k++)
        arr[esquerda + k] = temp[k];
}
```

**Entrada:** `[38, 27, 43, 3, 9, 82, 10]`  
**Saída:** `[3, 9, 10, 27, 38, 43, 82]`

📊 **Complexidade:** O(n log n)  
💾 **Espaço extra:** O(n)

---

## ⚡ 6. Quick Sort — O mais usado

💡 **Ideia:** escolhe um *pivô*, separa os menores à esquerda e os maiores à direita, e repete o processo.

```csharp
void QuickSort(int[] arr, int inicio, int fim) {
    if (inicio < fim) {
        int pivo = Particionar(arr, inicio, fim);
        QuickSort(arr, inicio, pivo - 1);
        QuickSort(arr, pivo + 1, fim);
    }
}

int Particionar(int[] arr, int inicio, int fim) {
    int pivo = arr[fim];
    int i = inicio - 1;

    for (int j = inicio; j < fim; j++) {
        if (arr[j] < pivo) {
            i++;
            (arr[i], arr[j]) = (arr[j], arr[i]);
        }
    }

    (arr[i + 1], arr[fim]) = (arr[fim], arr[i + 1]);
    return i + 1;
}
```

**Entrada:** `[10, 7, 8, 9, 1, 5]`  
**Saída:** `[1, 5, 7, 8, 9, 10]`

📊 **Complexidade Média:** O(n log n)  
⚠️ **Pior caso (array ordenado):** O(n²)

---

## 🔍 7. Busca Linear

💡 **Ideia:** percorre todos os elementos até encontrar o valor desejado.

```csharp
int BuscaLinear(int[] arr, int alvo) {
    for (int i = 0; i < arr.Length; i++)
        if (arr[i] == alvo)
            return i;
    return -1;
}
```

**Complexidade:** O(n)

---

## ⚡ 8. Busca Binária

💡 **Ideia:** busca eficiente **apenas em arrays ordenados**.  
Divide o espaço de busca ao meio a cada iteração.

```csharp
int BuscaBinaria(int[] arr, int alvo) {
    int esquerda = 0, direita = arr.Length - 1;
    while (esquerda <= direita) {
        int meio = (esquerda + direita) / 2;
        if (arr[meio] == alvo) return meio;
        if (arr[meio] < alvo) esquerda = meio + 1;
        else direita = meio - 1;
    }
    return -1;
}
```

**Entrada:** `[1, 3, 5, 7, 9]`, alvo = `7`  
**Saída:** `índice 3`

📊 **Complexidade:** O(log n)

---

## 🧩 9. Exercícios da Aula 09

**Ex 1.** Implemente o Bubble Sort e conte o número de trocas realizadas.  
**Ex 2.** Use o Insertion Sort para ordenar uma lista de strings em ordem alfabética.  
**Ex 3.** Aplique o Merge Sort em uma lista de 20 números aleatórios.  
**Ex 4.** Implemente a busca binária e teste com 10 valores diferentes.  
**Ex 5.** Compare o tempo de execução do Quick Sort e do Merge Sort com 1.000 elementos.

---

## 💪 10. Desafio Extra — Encontre o K-ésimo Maior Elemento

Implemente uma função que encontre o **k-ésimo maior elemento** de um array **sem ordenar totalmente** (usando Quickselect).

```csharp
int QuickSelect(int[] arr, int esquerda, int direita, int k) {
    if (esquerda == direita) return arr[esquerda];

    int pivoIndex = Particionar(arr, esquerda, direita);
    int posicao = pivoIndex - esquerda + 1;

    if (posicao == k) return arr[pivoIndex];
    else if (k < posicao) return QuickSelect(arr, esquerda, pivoIndex - 1, k);
    else return QuickSelect(arr, pivoIndex + 1, direita, k - posicao);
}
```

**Entrada:** `[3,2,1,5,6,4]`, k = 2  
**Saída:** `5`

📊 **Complexidade Média:** O(n)

---

## 🧠 11. Feynman — Explicação com Suas Palavras

Responda:
1. Qual algoritmo é mais rápido em geral: Merge ou Quick Sort?
2. Por que a busca binária é tão eficiente?
3. Quando usar Bubble Sort mesmo sendo lento?
4. Como a recursão é usada no Merge e Quick Sort?
5. O que acontece se aplicar busca binária em um array não ordenado?

📝 Escreva suas respostas em até **150 palavras**.
