# üìò Aula 07 ‚Äî Estruturas de Dados: Listas Ligadas (Linked Lists)

## üéØ Objetivos da Aula
- Entender o funcionamento interno de uma **lista ligada**.
- Compreender como os **n√≥s (nodes)** se conectam na mem√≥ria.
- Implementar opera√ß√µes b√°sicas: inser√ß√£o, remo√ß√£o, busca e itera√ß√£o.
- Diferenciar **listas simples**, **duplamente ligadas** e **circulares**.
- Resolver problemas comuns em entrevistas com Linked Lists.

---

## üß† 1. Conceito de Lista Ligada

Uma **lista ligada** √© uma estrutura onde cada elemento (**n√≥**) cont√©m:
1. Um **valor**.
2. Uma **refer√™ncia** (ponteiro) para o pr√≥ximo n√≥.

Diferente de arrays, **os elementos n√£o ocupam posi√ß√µes cont√≠guas na mem√≥ria**, o que permite inser√ß√µes e remo√ß√µes r√°pidas, mas dificulta o acesso direto por √≠ndice.

üí° **Analogia Feynman:**  
Pense em uma corrente: cada elo sabe quem √© o pr√≥ximo, mas n√£o quem veio antes.

---

## üß© 2. Estrutura de um N√≥

```csharp
class Node {
    public int Valor;
    public Node Proximo;

    public Node(int valor) {
        Valor = valor;
        Proximo = null;
    }
}
```

---

## üèóÔ∏è 3. Implementando uma Lista Ligada Simples

```csharp
class ListaLigada {
    private Node cabeca;

    public void InserirNoFinal(int valor) {
        Node novo = new Node(valor);
        if (cabeca == null) {
            cabeca = novo;
            return;
        }
        Node atual = cabeca;
        while (atual.Proximo != null) {
            atual = atual.Proximo;
        }
        atual.Proximo = novo;
    }

    public void Imprimir() {
        Node atual = cabeca;
        while (atual != null) {
            Console.Write(atual.Valor + " -> ");
            atual = atual.Proximo;
        }
        Console.WriteLine("null");
    }
}
```

**Exemplo de uso:**

```csharp
var lista = new ListaLigada();
lista.InserirNoFinal(10);
lista.InserirNoFinal(20);
lista.InserirNoFinal(30);
lista.Imprimir();
```

üìä **Sa√≠da:**
```
10 -> 20 -> 30 -> null
```

---

## ‚öôÔ∏è 4. Opera√ß√µes B√°sicas

| Opera√ß√£o | Descri√ß√£o | Complexidade |
|-----------|------------|---------------|
| **Inserir no in√≠cio** | Novo n√≥ aponta para o antigo in√≠cio | O(1) |
| **Inserir no final** | Percorre at√© o √∫ltimo e adiciona | O(n) |
| **Remover n√≥** | Atualiza ponteiros e libera mem√≥ria | O(n) |
| **Buscar valor** | Percorre at√© encontrar | O(n) |

---

### üìç Inserir no In√≠cio

```csharp
public void InserirNoInicio(int valor) {
    Node novo = new Node(valor);
    novo.Proximo = cabeca;
    cabeca = novo;
}
```

---

### üìç Remover um Valor

```csharp
public void Remover(int valor) {
    if (cabeca == null) return;

    if (cabeca.Valor == valor) {
        cabeca = cabeca.Proximo;
        return;
    }

    Node atual = cabeca;
    while (atual.Proximo != null && atual.Proximo.Valor != valor) {
        atual = atual.Proximo;
    }

    if (atual.Proximo != null)
        atual.Proximo = atual.Proximo.Proximo;
}
```

---

## üîÅ 5. Lista Duplamente Ligada

Cada n√≥ possui **duas refer√™ncias**: para o **anterior** e o **pr√≥ximo**.

```csharp
class NodeDuplo {
    public int Valor;
    public NodeDuplo Anterior;
    public NodeDuplo Proximo;
    public NodeDuplo(int valor) { Valor = valor; }
}
```

**Vantagens:**
- Pode ser percorrida em ambas as dire√ß√µes.
- Remo√ß√£o mais f√°cil.

**Desvantagens:**
- Maior uso de mem√≥ria.
- Implementa√ß√£o mais complexa.

---

## üîÅ 6. Lista Circular

O √∫ltimo n√≥ aponta de volta para o primeiro.  
Ideal para sistemas que precisam de itera√ß√£o cont√≠nua (como playlists ou buffers circulares).

```csharp
class ListaCircular {
    private Node cabeca;

    public void Inserir(int valor) {
        Node novo = new Node(valor);
        if (cabeca == null) {
            cabeca = novo;
            novo.Proximo = cabeca;
            return;
        }

        Node atual = cabeca;
        while (atual.Proximo != cabeca)
            atual = atual.Proximo;

        atual.Proximo = novo;
        novo.Proximo = cabeca;
    }
}
```

---

## üß© 7. Exerc√≠cios da Aula 07

**Ex 1.** Crie uma lista ligada e adicione elementos no in√≠cio e no final.  
**Ex 2.** Implemente uma fun√ß√£o `Buscar(int valor)` que retorne `true` se o valor estiver na lista.  
**Ex 3.** Escreva uma fun√ß√£o que conte o n√∫mero de n√≥s.  
**Ex 4.** Inverta uma lista ligada (sem usar listas auxiliares).  
**Ex 5.** Implemente uma lista duplamente ligada com m√©todos `Adicionar`, `Remover` e `Imprimir`.

---

## üí™ 8. Desafio Extra ‚Äî Detectar Ciclo em uma Lista

Use o **algoritmo de Floyd (Tartaruga e Lebre)** para detectar se h√° um ciclo em uma lista.

```csharp
bool TemCiclo(Node cabeca) {
    Node lento = cabeca;
    Node rapido = cabeca;

    while (rapido != null && rapido.Proximo != null) {
        lento = lento.Proximo;
        rapido = rapido.Proximo.Proximo;

        if (lento == rapido)
            return true;
    }

    return false;
}
```

**Entrada:** Lista com ciclo (ex: 1‚Üí2‚Üí3‚Üí4‚Üí2)  
**Sa√≠da:** `true`

---

## üß† 9. Feynman ‚Äî Explica√ß√£o com Suas Palavras

Responda:
1. O que √© um n√≥ em uma lista ligada?
2. Qual a diferen√ßa entre lista ligada e array?
3. Quando usar uma lista ligada em vez de um vetor?
4. O que √© uma lista circular?
5. Como o algoritmo da tartaruga e lebre detecta ciclos?

üìù Escreva suas respostas em at√© **150 palavras**.
