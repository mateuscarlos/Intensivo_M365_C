# 📘 Aula 10 — Programação Dinâmica e Entrevista Técnica (Dynamic Programming & Mock Interview)

## 🎯 Objetivos da Aula
- Compreender o conceito e a motivação da **Programação Dinâmica (DP)**.
- Aprender a resolver problemas complexos por meio de **subproblemas** e **memorização**.
- Implementar algoritmos clássicos de DP em C#.
- Desenvolver raciocínio técnico para entrevistas.
- Simular uma entrevista técnica real com problemas Microsoft.

---

## 🧠 1. O Que é Programação Dinâmica?

A **Programação Dinâmica (DP)** é uma técnica usada para resolver problemas **recorrentes** e **sobrepostos**, armazenando resultados de subproblemas para evitar recomputação.

💡 **Analogia Feynman:**  
Imagine escalar uma escada de 100 degraus.  
Você pode subir 1 ou 2 degraus por vez.  
Ao invés de recalcular todos os caminhos possíveis a cada passo, você **lembra** quantas formas havia de chegar nos degraus anteriores.

---

## ⚙️ 2. Tipos de DP

| Tipo | Descrição | Exemplo |
|------|------------|----------|
| **Top-Down (Memorização)** | Usa recursão e guarda resultados já calculados. | Fibonacci recursivo com cache |
| **Bottom-Up (Tabulação)** | Usa laços para preencher uma tabela iterativamente. | Caminhos em grade (matriz) |

---

## 🧩 3. Exemplo Clássico: Fibonacci

### 🧮 Solução Recursiva (ineficiente)

```csharp
int Fib(int n) {
    if (n <= 1) return n;
    return Fib(n - 1) + Fib(n - 2);
}
```

📊 **Complexidade:** O(2ⁿ)

---

### ⚡ Solução com DP (Top-Down)

```csharp
Dictionary<int, int> memo = new Dictionary<int, int>();

int FibDP(int n) {
    if (n <= 1) return n;
    if (memo.ContainsKey(n)) return memo[n];

    memo[n] = FibDP(n - 1) + FibDP(n - 2);
    return memo[n];
}
```

📊 **Complexidade:** O(n)

---

### 🧮 Solução com DP (Bottom-Up)

```csharp
int FibTab(int n) {
    if (n <= 1) return n;
    int[] dp = new int[n + 1];
    dp[0] = 0; dp[1] = 1;

    for (int i = 2; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];

    return dp[n];
}
```

📊 **Complexidade:** O(n)  
💾 **Espaço:** O(n)

---

## 🎒 4. Problema da Mochila (Knapsack Problem)

**Descrição:** Dado um conjunto de itens com peso e valor, determine o valor máximo que pode ser carregado em uma mochila com capacidade limitada.

```csharp
int Mochila(int[] peso, int[] valor, int capacidade, int n) {
    if (n == 0 || capacidade == 0) return 0;

    if (peso[n - 1] > capacidade)
        return Mochila(peso, valor, capacidade, n - 1);

    else
        return Math.Max(
            valor[n - 1] + Mochila(peso, valor, capacidade - peso[n - 1], n - 1),
            Mochila(peso, valor, capacidade, n - 1)
        );
}
```

📊 **Complexidade:** O(2ⁿ) (recursiva) — pode ser otimizada com DP.

---

### ⚙️ Solução DP (Bottom-Up)

```csharp
int MochilaDP(int[] peso, int[] valor, int capacidade) {
    int n = peso.Length;
    int[,] dp = new int[n + 1, capacidade + 1];

    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= capacidade; w++) {
            if (i == 0 || w == 0)
                dp[i, w] = 0;
            else if (peso[i - 1] <= w)
                dp[i, w] = Math.Max(valor[i - 1] + dp[i - 1, w - peso[i - 1]], dp[i - 1, w]);
            else
                dp[i, w] = dp[i - 1, w];
        }
    }
    return dp[n, capacidade];
}
```

**Entrada:** pesos `[1,3,4,5]`, valores `[1,4,5,7]`, capacidade `7`  
**Saída:** `9`

---

## 🧩 5. Subsequência Comum Máxima (LCS)

**Descrição:** Dadas duas strings, encontre o comprimento da maior subsequência comum.

```csharp
int LCS(string s1, string s2, int m, int n) {
    if (m == 0 || n == 0) return 0;

    if (s1[m - 1] == s2[n - 1])
        return 1 + LCS(s1, s2, m - 1, n - 1);
    else
        return Math.Max(LCS(s1, s2, m - 1, n), LCS(s1, s2, m, n - 1));
}
```

### 🔁 Solução DP (Bottom-Up)

```csharp
int LCS_DP(string s1, string s2) {
    int m = s1.Length, n = s2.Length;
    int[,] dp = new int[m + 1, n + 1];

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i - 1] == s2[j - 1])
                dp[i, j] = 1 + dp[i - 1, j - 1];
            else
                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
        }
    }
    return dp[m, n];
}
```

**Entrada:** `"ABCBDAB"` e `"BDCABA"`  
**Saída:** `4` (BCBA)

---

## 🧩 6. Exercícios da Aula 10

**Ex 1.** Implemente Fibonacci usando DP (Top-Down e Bottom-Up).  
**Ex 2.** Resolva o problema da mochila com 5 itens e capacidade 10.  
**Ex 3.** Crie uma função que conte o número de formas de subir uma escada de `n` degraus (1 ou 2 por vez).  
**Ex 4.** Implemente o LCS para duas strings e exiba a subsequência resultante.  
**Ex 5.** Escreva uma função DP para calcular o mínimo de moedas necessárias para atingir um valor alvo.

---

## 💪 7. Desafio Final — Mock Interview Microsoft

**Problema:**  
Dado um array de inteiros, encontre o **subarray contíguo** com a **maior soma possível**.

💡 **Dica:** Esse é o **Algoritmo de Kadane**, clássico em entrevistas.

```csharp
int MaxSubArray(int[] nums) {
    int maxAtual = nums[0], maxTotal = nums[0];

    for (int i = 1; i < nums.Length; i++) {
        maxAtual = Math.Max(nums[i], maxAtual + nums[i]);
        maxTotal = Math.Max(maxTotal, maxAtual);
    }

    return maxTotal;
}
```

**Entrada:** `[-2,1,-3,4,-1,2,1,-5,4]`  
**Saída:** `6` (subarray `[4,-1,2,1]`)

📊 **Complexidade:** O(n)

---

## 🧠 8. Feynman — Explicação com Suas Palavras

Responda:
1. O que é Programação Dinâmica e quando aplicá-la?
2. Qual a diferença entre memorização e tabulação?
3. Por que DP é mais eficiente que recursão simples?
4. Como o problema da mochila se aplica a decisões reais?
5. Como você explicaria o algoritmo de Kadane a um colega?

📝 Escreva suas respostas em até **200 palavras**.

---

## 🧭 Conclusão

Parabéns! 🎉  
Você completou o ciclo de preparação intensiva para o teste técnico da Microsoft M365.

A partir daqui:
- Pratique os problemas novamente no **HackerRank**.  
- Foque em **limpeza de código**, **nomes claros** e **explicações curtas, mas completas**.  
- Lembre-se: o entrevistador avalia **como você pensa**, não só se acerta o código.

> ✨ “First, solve the problem. Then, write the code.” – John Johnson
